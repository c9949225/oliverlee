后台得到数据，处理成xml，然后前台用js处理xml文件就好办了，具体可以查ajax请求xml的资料

B/S结构的权限控制如果只做在UI层次是不可取的,因为你永远都不知道用户会post什么数据过来,

例如一个html的select你只给了3个选项, 但是"聪明"的用户会自己post n个选项过来...

所以权限控制还是要做到后台的业务逻辑里面.

比较典型的做法,将前台业务按照模块细分编号,将编号与后台的用户权限表进行映射.... 




　但是，问题领域的某些需求却偏偏不是用这样的“名词”来描述的。
  比如遇到这样的问题：需要对系统中的某些方法进行权限检验，这种需要权限检验的方法散布在 
  40多个类中。面对这种需求，应该怎么办呢？最直接的办法就是：创建一个起类（或接口），
  将权限检验的功能放在其中，并让所有需要权限检验的类继承这个起类（或接口）．
  如果这个需求是后期提出的．需要修改的地方就会分散在40多个文件中。这样大的修改量，
  无疑会增加出错的几率，并且加大系统维护的难度。


   对于权限管理的做法，在WEB实现上，有以下几种：

　　⑴ 利用Filter，对所有进入的URI进行解析，并取得当时Session中的User信息，
   然后通过RBAC的机制，将此链接需要的权限与用户拥有的权限进行比较，然后进行相应的处理。
   这种做法有很多好处：简单，容易实现，并且对系统侵入性也不强。
   这里URL就是RBAC中的资源了。这样做的缺点是所有对数据的操作必须通过URL来体现，
   这一点在现代的程序中不太好实现。如果采用Struts, XWork或者Tapestry，
   采用同一个URL（浏览器看来）进行处理多项任务已不是什么稀奇的事。
   
   ⑵ 利用一个BaseServlet(Servlet+Jsp经典模式)或者BaseAction(Struts模式)或者BasePage (Tapestry模式)或者BaseController(SpringMVC模式)，
   对所有的请求先进行过滤进行权限操作，然后再处理。
   稍微看一下就知道这种模式跟Filter并无本质不同。优缺点同上。
   
------------------------------------------------------------------------
   那么，如果要实现更为细致的权限操作，精确到某个方法的权限，典型的做法如下：

public someFunciton() {
　//权限判断
　User user = context.getUser();
　if (user.canExecuteThisFunction()) {
　　// do the business method
　　// ...
　} else {
　　throw new PermissionDeniedException();
　}
}
  
-------------------------------------------------------------------------

　这种做法能够将权限的粒度控制到具体的业务方法，因此它的控制能力应该是强大的。可以看到，权限判断部分对于每个方法几乎是独立的。

　　这种在具体功能前加入权限操作检验的实现方式有很多缺点：

　　⑴ 每个功能类都需要相应的权限检验代码，将程序功能和权限检验混淆在一起，存在紧密的耦合性，扩展修改难度大。

　　⑵ 以代理模式为每个功能类实现一个相应的代理类，虽然解耦了程序功能和权限检验，但是，从某个角色的权限检验这个切面考虑，涉及具体Proxy类太多，扩展修改难度大。


Struts调用request.isUserInRole()来检查用户是否有权限执行当前的ActionMapping；这时如果你想通过查询数据库来实现，你所要做的就是重写processRoles()方法，通过查询出的用户是否拥有必须的权限来返回true或false。
 