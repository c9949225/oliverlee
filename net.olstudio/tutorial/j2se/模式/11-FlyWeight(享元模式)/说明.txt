享元模式属于结构型模式，其意图是运用共享技术有效地支持大量细粒度的对象。

有些应用程序得益于在其整个设计过程中采用面向对象技术，但是简单化的实现代价极大。

flyweight是一个共享对象，它可以同时在多个场景中使用，
并且每个场景中Flyweight队作为一个独立的对象，
这一点与非共享对象的实例没有区别，Flyweight不能对他所运行的场景作出任何假设，
这里的关键概念是内部状态和外部状态之间的区别。内部状态存储于Flyweight中，
它包含了独立Flyweight场景的信息，这些信息使得Flyweight可以被共享，
而外部状态取决于 Flyweight场景，并根据场景而变化，因此不可共享，
用户对象负责在必要的时候将外部状态传递给Flyweight，
Flyweight模式对那些通常因为数量太大而难以用对象来表示的概念或者实体建立模型。

       适用性：Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它，当以下情况都成立时使用Flyweight模式。
l         
		     一个应用程序使用了大量的对象，
l         
		    完全有余使用了大量的对象，造成了很大的存储开销。
l         
                           对象的大多数状态都可以变为外部状态。
l         
                           如果删除对象的外部状态那么可以用相对较少的共享对象取代很多组对象。
l         
                           应用程序不依赖于对象标识，由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。


参与者：      
       Flyweight:描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。
       ConcreteFlyweight(MyImage)：实现flyweight接口，并为内部状态增加存储空间。ConcreteFlyweight对象必须是可以共享的，它所存储的状态必须是内部的。即：它必须独立于ConcreteFlyweight对象的场景.
UnsharedConcreteFlyweight:并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享，在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将ConcreteFlyweight对象作为子节点。
FlyweightFactory(MyImageFactory)：创建并管理Flyweight对象。确保合理的共享Flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已经创建的实例或者创建一个。
Client：维持一个对Flyweight的引用。计算或者存储一个（多个）flyweight的外部状态。Flyweight执行时所需要的状态必定是内部的或者外部的状态，内部状态存储于ConcreteFlyweight对象中，而外部对象则由Client对象存储或计算，当用户调用flyweight对象的操作时，将该状态传递给他。用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对他们适当的进行共享。


本人认为Flyweight模式的核心就是把大量"共享"的对象"收集"在一起使用简单工厂模式进行管理，
避免由于大量的小对象导致系统的内存过渡消耗。

下面是一个简单的例子，例子不是很好，并不能显示Flyweight模式的所有特征。
客户端需要图片，从MyImageFactory中取得，如果MyImageFactory存储的Image中没有需要的图片,便创建一个，并把创建的图片存储在保留Flyweight的数组中，以便于下次直接获取。

总结：Flyweight的目标是尽量减少大量可以被共享的对象的数目，并把可变的与不可变得状态使用内部状态(Flyweight)与外部状态区分开来。