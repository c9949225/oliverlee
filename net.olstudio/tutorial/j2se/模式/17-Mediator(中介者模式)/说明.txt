  中介者模式属于行为型模式，
  
  其意图是用一个中介对象封装一系列的对象交互。
  中介者使各对象不需要显式的相互调用，从而使其耦合松散，
  而且可以独立地改变他们之间爱女的交互。
  
  面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多连接，
  
  在最坏的情况下，每一个对象都知道其他所有的对象，这无疑复杂化了对象之间的联系。
  
  虽然将一个系统分割成许多对象通常可以增强可复用性，
  但是对象间相互连接的激增又会降低其可复用性，
  
  大量的相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，
  
  系统表现为一个不可分割的整体，而且对系统的行为进行任何较大的改动都会十分困难。
  结果是你不得不定义大量的子类以定制系统的行为。
  
  在Java世界中，Button按钮和监听者之间通过Frame进行协作，Frame就类是一个中介者。
  
  中介者模式和操作系统的原语P,V操作有相似之处，
  比如典型的PV操作场景：一个进程为消费者，一个进程为生产者，当生产者需要生产产品，就向产品储藏的队列询问，如果有剩余的空间，则生产一个产品，否则就睡眠，消费者进程也一样，如果有产品可以消费则消费产品，否则就睡眠直到产品生产出来可以供消费。
 
       适用性：在下列情况下使用中介者模式：
l         一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱并且难以理解。
l         一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
l         想定制一个分布在多个类中的行为，而又不想生成太多的子类。
参与者：
       Mediator(中介者)：中介者定义一个接口用于与各同事对象通信。
       ConcreteMediator(具体中介者)：具体中介者通过协调各同事对象实现协作行为。了解并维护它的各个同事。
       Colleague Class(中介者类)：每一个同事者类都知道他的中介者对象，每一个同事对象在需要与其他的同事者通信的时候，与他的中介者通信。
       
       协作：同事向一个中介者对象发送和接收请求，中介者在各同事间适当地转发请求以实现协作行为。
中介者模式的优点和缺点：
1.         减少了子类生成，Mediator将原本分布在各同事间的行为集中在一起。改变这些行为只需要生成Mediator的子类即可。这样各个Colleague类可被重用。
2.         他将各Colleague解耦， Mediator有利于各Colleague间的松耦合，你可以独立的改变和复用各Colleague类和Mediator类。
3.         它简化了对象协议， 用Mediator和各Colleague间的一对多的交互来代替多对多的交互，一对多的关系更容易理解、维护和扩展。
4.         他对对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到他们之间的交互上来。
5.         它使控制集中化 中介者模式将交互的复杂性变为中介者的复杂性，因为中介者封装了协议，它可能变得比任何一个Colleague都复杂，这可能使得中介者自身变成一个难以维护的庞然大物。