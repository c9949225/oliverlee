 迭代器模式属于行为型模式，
 
总结：Iterator模式提供了一个访问聚合数据的简单思路，并支持多个迭代器同时访问。

其意图是提供一种方法顺序访问一个聚合对象中得各个元素，
而又不需要暴露该对象的内部表示。

一个聚合对象，比如列表，应该提供一种方法来让别人可以访问他的元素。
而又不需要暴露他的内部结构，
此外，针对不同的需求，可能要以以下不同的方式遍历这个列表，
但是即使可以预见所需要的那些遍历操作，你可能也不希望列表的接口中充斥着各种不同的遍历操作。

有时还可能需要在同一个列表上同时进行多个遍历。
迭代器模式可以帮助你解决所有这些问题。
这一个模式的关键思想市将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，
迭代器类定义了一个访问该列表元素的接口，迭代器对象负责跟踪当前的元素，
即他知道那些元素已经遍历过了。在实例化列表迭代器之前，必须提供待遍历的列表，
一旦有了该列表迭代器的实例，就可以顺序访问该列表的各个元素。
CurrentItem操作返回列表中得当前元素，First操作初始化迭代器，
使当前元素指向列表的第一个元素，Next操作将当前元素指针向前推进一步，指向下一个元素，
而IsDone检查是否已经越过最后一个元素，也就是完成了这次遍历。

例如常见的电视，可以定义一个遥控器的，每个工厂生产的电视机都有配套的遥控器，这有点像抽象工厂模式，但是现在不是说抽象工厂模式，而说的重点是迭代器模式，电视的频道为Item，每个遥控器都会有遍历的功能，用以遍历所有的频道。如下图所示，
适用性：
l         访问一个聚合对象的内容而无需暴露他的内部表示。
l         支持对句和对象的多遍遍历。
l         为遍历不同的聚合结构提供一个统一的接口。
参与者：
       Iterator：迭代器定义访问和遍历元素的接口。
       ConcreteIterator(Controller)：具体迭代器实现迭代器接口，对该聚合遍历时跟踪当前位置。
       Aggregate（Televation）:聚合定义了创建相应迭代器对象的接口。
       ConcreteAggregate(HaierTV):具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。
协作关系：ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。
 
使用迭代器的好处：
1.         他支持以不同的方式遍历一个聚合， 复杂的聚合可用多种方式进行遍历。
2.         迭代器简化了聚合的接口 有了迭代器的遍历接口，聚合本身就不需要类似的遍历接口了，这样就简化了聚合的接口。
3.         在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。
在本例子中，Television定义了一个返回各个频道列表的接口，这实际上是一个工厂方法，只是生产出来的产品所属的类型支持Iterator的操作。
具体的代码如下所示：

